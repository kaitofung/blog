<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Kaito's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Kaito's blog">
<meta property="og:url" content="kaitofung.cn/index.html">
<meta property="og:site_name" content="Kaito's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kaito's blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="kaitofung.cn/"/>

  <title> Kaito's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Kaito's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/06/HashMap工作原理/" itemprop="url">
                  HashMap工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-06T10:18:07+08:00" content="2017-01-06">
              2017-01-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/06/HashMap工作原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/06/HashMap工作原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官方文档对HashMap的一段描述：</p>
<blockquote>
<p>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p>
</blockquote>
<p>可以看出HashMap具有的特点：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p>
<h1 id="一、HashMap数据结构"><a href="#一、HashMap数据结构" class="headerlink" title="一、HashMap数据结构"></a>一、HashMap数据结构</h1><p>HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。</p>
<p><img src="http://oekcs3wuy.bkt.clouddn.com/HashMap%E7%BB%93%E6%9E%84.png" alt=""></p>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><pre><code>transient Entry[] table;//存储元素的实体数组

transient int size;//存放元素的个数

int threshold; //临界值   当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量

 final float loadFactor; //加载因子

transient int modCount;//被修改的次数
</code></pre><p>其中loadFactor加载因子是表示Hsah表中元素的填满的程度.<br>若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。</p>
<p>反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）<br>冲突的机会越大,则查找的成本越高.</p>
<p>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.<br>如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>
<p>put方法的实现    </p>
<ul>
<li></li>
</ul>
<pre><code>public V put(K key, V value) {
    // 对key的hashCode()做hash
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // tab为空则创建
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // 计算index，并对null做处理
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        // 节点存在
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // 该链为树
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // 该链为链表
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        // 写入
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // 超过load factor*current capacity，resize
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre><p>put函数大致的思路为：</p>
<ol>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；（JDK1.8）</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ol>
<p>其中对key的hashCode()做hash的作用是为了过滤劣质的HashMap算法产生的Hash码，尽可能地减少Hash碰撞，使元素尽可能地分布在bucket中。可以增加查询效率。</p>
<pre><code>1     static int indexFor(int h, int length) { //根据hash值和数组长度算出索引值
2         return h &amp; (length-1);  //这里不能随便算取，用hash&amp;(length-1)是有原因的，这样可以确保算出来的索引是在数组大小范围内，不会超出
3     }
</code></pre><p>这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p>
<p>  接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</p>
<p>resize()方法的实现</p>
<ul>
<li><pre><code>final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) {
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 没超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    }
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 计算新的resize上限
    if (newThr == 0) {

        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        // 原索引
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 原索引+oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
</code></pre></li>
</ul>
<p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>   那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<p>get方法的实现</p>
<ul>
<li><pre><code>public V get(Object key) {
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        // 直接命中
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 未命中
        if ((e = first.next) != null) {
            // 在树中get
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 在链表中get
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre></li>
</ul>
<p>大致思路如下：</p>
<ol>
<li>bucket里的第一个节点，直接命中；</li>
<li>如果有冲突，则通过key.equals(k)去查找对应的entry<br>若为树，则在树中通过key.equals(k)查找，O(logn)；<br>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ol>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3948406.html#a10" target="_blank" rel="external">Java集合—HashMap源码剖析</a></p>
<p><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">Java HashMap工作原理及实现 </a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/Handler的工作流程/" itemprop="url">
                  Handler的工作流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T05:13:21+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/13/Handler的工作流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/13/Handler的工作流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://oekcs3wuy.bkt.clouddn.com/Handler%E5%AE%98%E6%96%B9%E7%AE%80%E5%8D%95%E7%AE%80%E7%BB%8D.png" alt=""></p>
<p>通过官方文档，可以看到Handler有两大作用：</p>
<p>1.作为一个计时器</p>
<p>2.切换线程操作</p>
<p>对于这两大作用的写法都是实例化一个Handler对象，然后通过postXXX或者sendXXX的形式发送一个消息或Runnable的。</p>
<p>Read The Fucking Source code,梳理下工作流程：</p>
<p><img src="http://oekcs3wuy.bkt.clouddn.com/Handler%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B0.png" alt=""></p>
<p>分析可知：</p>
<p><strong>1.Handler对象的实例化是需要一个Looper对象的，而Looper的构造方法是private的，所以可以通过Looper.prepare()实例化一个有且仅有一个的Looper对象,用一个ThreadLocal维护在本线程的 Thread Local Storege.</strong></p>
<p><strong>2.Handler的postXXX或者sendXXX最终都会调用sendMessageAtTime(Message msg,long updatetimeMills),然后调用此Handler绑定的MessageQueue对象的enqueueMessage(msg, uptimeMillis)把通信消息入列.</strong></p>
<p><strong>3.通过Looper.loop()循环地向与其绑定的MessageQueue中取出信息，其中queue.next()有可能引起阻塞。取出的Message通过调用与之绑定的TargetHandler的dispatchMessage(Message msg)进行处理.</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/19/View的呈现过程——之浅谈ViewRootImpl/" itemprop="url">
                  View的呈现过程——之浅谈ViewRootImpl
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-19T21:15:44+08:00" content="2016-06-19">
              2016-06-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/19/View的呈现过程——之浅谈ViewRootImpl/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/19/View的呈现过程——之浅谈ViewRootImpl/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.kaitofung.cn/2016/05/05/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-View%E7%9A%84%E5%91%88%E7%8E%B0%E8%BF%87%E7%A8%8B%E2%80%94%E2%80%94%E4%B9%8BsetContentView/" title="View的呈现过程——之setContentView " target="_blank" rel="external">上一遍文章</a>结束的时候谈到View要经过测量，布局，绘制才能呈现。那么什么时候才会执行这几个步骤呢？相信接触过自定义View的同学都会知道是invalidate()可以引起重绘的。<br>下面通过Read The Fucking Source Code，整理出以下流程：<br><img src="http://oekcs3wuy.bkt.clouddn.com/View%E7%9A%84invalidate%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="View的invalidate流程"></p>
<p>通过三种颜色区分，分别在View.ViewGroup,ViewRootImpl调用相应的方法，可见</p>
<p><strong>1.View的UI刷新是在View树的顶层View的ViewParent（即ViewRootImpl）进行刷新的；</strong></p>
<p><strong>2.当View的AttachInfo为空的时候是没有进行线程安全检验的且中断了invalidate；</strong></p>
<p><strong>3.线程安全监测是在ViewRootImpl的invalidateChildInParent方法执行的.</strong></p>
<p>UI从无到有，显然是执行了是viewRootImpl.PerformTraversal()方法后才能成功刷新UI的，那么一个ViewRootImpl是在什么时候被实例化的？什么时候调用PerformTraversal()呢？通过查阅资料，得知，Activity的启动试过ActivityThread类的如下方法</p>
<pre><code>private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;
        if (r.profilerInfo != null) {
            mProfiler.setProfiler(r.profilerInfo);
            mProfiler.startProfiling();
        }
        // Make sure we are running with the most recent config.
        handleConfigurationChanged(null, null);
        if (localLOGV) Slog.v(
            TAG, &quot;Handling launch of &quot; + r);
        // Initialize before creating the activity
        WindowManagerGlobal.initialize();
        /**
         * Activity的Attach被调用，PhoneWindow与Activity建立关系,
         * 并且通过mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
         * 进行Activity的onCreate回调，没有出现performTraversal的身影。
         */
        Activity a = performLaunchActivity(r, customIntent);
        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);

           ...
        }
    }
</code></pre><p>没有出现performTraversal，继续看</p>
<p>handleResumeActivity(r.token, false, r.isForward,<br>                        !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</p>
<pre><code>final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) { 
    //...
    ActivityClientRecord r = performResumeActivity(token, clearHide); // 这里会调用到onResume()方法

    if (r != null) {
        final Activity a = r.activity;

        //...
        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {
            r.window = r.activity.getWindow(); // 获得window对象
            View decor = r.window.getDecorView(); // 获得DecorView对象
            decor.setVisibility(View.INVISIBLE);
            ViewManager wm = a.getWindowManager(); // 获得windowManager对象
            WindowManager.LayoutParams l = r.window.getAttributes();
            a.mDecor = decor;
            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
            l.softInputMode |= forwardBit;
            if (a.mVisibleFromClient) {
                a.mWindowAdded = true;
                wm.addView(decor, l); // 调用addView方法
            }
            //...
        }
    }
}
</code></pre><p>可见<a href="http://blog.kaitofung.cn/2016/05/05/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-View%E7%9A%84%E5%91%88%E7%8E%B0%E8%BF%87%E7%A8%8B%E2%80%94%E2%80%94%E4%B9%8BsetContentView/" target="_blank" rel="external">上一篇文章探讨的setContentView</a>方法仅是创建了DecorView，若要进行UI刷新，必须依靠ViewRootImpl。DecorView与ViewRootImpl是通过Activity的WindowManager建立起关系在handleResumeActivity方法中的wm.addView(decor, l);WindowManager是抽象类，它的实现类是WindowManagerImpl，所以后面调用的是WindowManagerImpl.addView(View view, ViewGroup.LayoutParams params)方法，继续看WindowManagerImpl源码：</p>
<pre><code>public final class WindowManagerImpl implements WindowManager {    
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    ...
    @Override
    public void addView(View view, ViewGroup.LayoutParams params) {
        mGlobal.addView(view, params, mDisplay, mParentWindow);
    }
}
</code></pre><p>接着调用了mGlobal的成员函数，而mGlobal则是WindowManagerGlobal的一个实例，那么我们接着看WindowManagerGlobal.addView方法：</p>
<pre><code>public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        ...

        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) {
            ...

            root = new ViewRootImpl(view.getContext(), display); 

            view.setLayoutParams(wparams);

            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView); 
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index &gt;= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
    }
</code></pre><p>清晰可见，ViewRootImpl是在WindowManagerGlobal的addView方法实例化的，通过root.setView(view, wparams, panelParentView)方法，ViewRootImpl与Decor建立关系了。</p>
<pre><code>public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    //...
    requestLayout();
    //...
}

public void requestLayout() {
    if (!mHandlingLayoutInLayoutRequest) {
        checkThread();
        mLayoutRequested = true;
        scheduleTraversals();
    }
}
</code></pre><p>阅读ViewRootImpl的setView(View view, WindowManager.LayoutParams attrs, View panelParentView)与requestLayout()可以看到<br> scheduleTraversals()的身影了。这就跟上述自定义View调用invalidate的最后几个流程一样了。performTraversals()执行完毕就完成了View的测量，布局，绘制了。</p>
<p><strong>总结：View的UI刷新是依赖于ViewRootImpl的performTraversals()，而Activity的首次UI树遍历发生在WindowManagerGlobal的addView方法中。</strong></p>
<p>本文章部分内容参考了：<br><a href="http://www.jianshu.com/p/687010ccad66" target="_blank" rel="external">Android View源码解读：浅谈DecorView与ViewRootImpl</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/05/View的呈现过程——之setContentView/" itemprop="url">
                  View的呈现过程——之setContentView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-05T22:37:25+08:00" content="2016-05-05">
              2016-05-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/05/View的呈现过程——之setContentView/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/05/View的呈现过程——之setContentView/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###猜想：View是在Activity的setContentView()方法后呈现的</p>
<p>###阅读源代码验证</p>
<pre><code>public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);  //通过attach()实例化的PhoneWindow实例来setContentView
    initWindowDecorActionBar();  //初始化ActionBar
}
</code></pre><p> 从以上代码片段可以看出做了两件事情，继续查看PhoneWindow的setContentView(layoutResID)</p>
<pre><code>// This is the view in which the window contents are placed. It is either
// mDecor itself, or a child of mDecor where the contents go.
private ViewGroup mContentParent;

// This is the top-level view of the window, containing the window decor.
//通过查看View Hierachy可以知道顶层的DecorView为一个FrameLayout的子类实例
private DecorView mDecor;
    @Override
    public void setContentView(int layoutResID) {
    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
    // decor, when theme attributes and the like are crystalized. Do not check the feature
    // before this happens.
    if (mContentParent == null) {  //A
    installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
    mContentParent.removeAllViews();
    }
    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
    final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
    getContext());
    transitionTo(newScene);
    } else {
    mLayoutInflater.inflate(layoutResID, mContentParent);//B
    }
    mContentParent.requestApplyInsets();
    final Callback cb = getCallback();
    if (cb != null &amp;&amp; !isDestroyed()) {
    cb.onContentChanged();
    }
    mContentParentExplicitlySet = true;
    } 
</code></pre><p>以上代码的主要工作：</p>
<p>1.mContentParent为空的时候调用installDecor(),</p>
<p>2 mLayoutInflater.inflate(layoutResID, mContentParent);把布局加载到mContentParent.</p>
<pre><code>private void installDecor() {
    if (mDecor == null) {
        mDecor = generateDecor(); // A
   /*
    * setDescendantFocusability用于设置mDecor中的子View的聚焦性
    * 该方法决定了mDecor与其中包含的子View之间关于焦点获取的关系
    * FOCUS_AFTER_DESCENDANTS表示只有当mDecor的子View都不愿意获取焦点时 才让mDecor获取焦点
    */
        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
       // 设置mDecor为整个Activity窗口的根节点，从此处可以看出窗口根节点为一个DecorView
        mDecor.setIsRootNamespace(true);
        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) {
            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
        }
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor); // B
        ...
        } 
    }
}

protected DecorView generateDecor() {
    return new DecorView(getContext(), -1);
}
</code></pre><p>installDecor()主要工作：</p>
<p>1.generateDecor()</p>
<p>2.generateLayout(mDecor)</p>
<pre><code>//返回当前Activity的内容区域视图，即我们的布局文件显示区域mContentParent
protected ViewGroup generateLayout(DecorView decor) {
        // Apply data from current theme.
        //从当前Window的Theme中获取一组属性值，赋给a
        TypedArray a = getWindowStyle();
        /*
   * 此处有段代码未贴出，功能为：
   * 1. 根据Activity的Theme特征，为当前窗口选择布局文件的修饰feature
   * 2. Inflate the window decor
   */
        int layoutResource;
        int features = getLocalFeatures();
  /*
   * 此处有段代码未贴出
   * 1. getLocalFeatures()返回一个用于描述当前Window特征的整数值
   * 2. layoutResource为根据features所指代的窗口特征值而为当前窗口选定的资源文件id
   * 3. 系统包含多个布局资源文件，位于frameworks/base/core/res/layout/
   * 4. 主要有：R.layout.dialog_titile_icons、R.layout.screen_title_icons
   *     R.layout.screen_progress、R.layout.dialog_custom_title
   *     R.layout.dialog_title   
   *     R.layout.screen_title    最常用的Activity窗口修饰布局文件
   *        R.layout.screen_simple   全屏的Activity窗口布局文件
   */
  //startChanging()方法内容：mChanging = true;
        mDecor.startChanging();
  //将layoutResource资源文件包含的View树添加到decor中
  //width和height均为MATCH_PARENT
  //并为mContentRoot和contentParent赋值
        View in = mLayoutInflater.inflate(layoutResource, null);
        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
        mContentRoot = (ViewGroup) in;
        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
        if (contentParent == null) {
            throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);
        }
        if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) {
            ProgressBar progress = getCircularProgressBar(false);
            if (progress != null) {
                progress.setIndeterminate(true);
            }
        }
        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) {
            registerSwipeCallbacks();
        }
        //后面包含一段只能应用于顶层窗口的一些Remaining steps
        //主要用于设置一些title和background属性
        return contentParent;
}
</code></pre><p><strong>综合来看，setContentView的工作是为Activity所持有的PhoneWindow引用创建了DecorView，并通过(ViewGroup)findViewById(ID_ANDROID_CONTENT)返回了mContentParent，然后通过 mLayoutInflater.inflate(layoutResID, mContentParent);把我们的布局inflate到mContentParent中。</strong></p>
<p>通过源码setContentView的源码可知，此时View是未能呈现的，因为从代码片段未测量，布局，绘制的相关方法。所以此时直接通过getWide，getMeasureWith获取到都是为0。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars3.githubusercontent.com/u/17872493?v=3&s=466"
               alt="Kaito Fung" />
          <p class="site-author-name" itemprop="name">Kaito Fung</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaito Fung</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"kaito"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
